# Request for Comments: Weighted Matching System for Browser Fingerprinting

Note: This RFC was generated by OpenAI's GPT-4o in May 2024 (and revised in June 2024) summarizing my (Joe Rutkowski / Joe12387) overall theory in processing numerous fingerprinting values/hashes from different methods/modules/components implemented in OverpoweredJS. This is generally just an example of how fingerprinting values produced by OverpoweredJS may be handled. There are almost certainly more efficient ways of processing this data in order to implement tracking and this method does have some issues which could be resolved by another whitepaper. If you have a theory on how to better process this data, please submit a pull request adding your RFC to the `whitepapers` folder. Thanks!

## Abstract

This document describes the specifications and implementation details of a weighted matching system for browser fingerprinting. The system is designed to identify unique browser instances by comparing various fingerprinting methods and assigning weights based on the uniqueness of their values. The goal is to achieve accurate fingerprint matching while optimizing performance and scalability.

## 1. Introduction

Browser fingerprinting is a technique used to identify and track individual browsers by collecting various pieces of information about the browser and the device it is running on. This system aims to enhance the accuracy of browser fingerprinting by assigning weights to different fingerprinting methods based on their uniqueness and comparing them to a database of previously captured fingerprints.

## 2. Objectives

- To assign weights to different fingerprinting methods based on the number of unique values they can generate.
- To compare client fingerprints against a database of known fingerprints and determine matches based on weighted scores.
- To add new fingerprints to the database if no match is found.
- To ensure the system is scalable and can handle a large volume of requests efficiently.

## 3. Fingerprinting Methods

The system uses several fingerprinting methods, each with a different range of unique values. Examples include:
- `navigator.platform`
- `WebGL fingerprint`
- `navigator.userAgent`
- `screen.width` & `screen.height`
- `timezone`

## 4. Weighting System

### 4.1 Calculation of Weights

Weights are assigned to each fingerprinting method based on the logarithm of the number of unique values they can generate. This ensures that methods with a larger range of values have a higher weight, reflecting their greater contribution to identifying a unique browser instance.

#### Formula

\[ W_{method} = \log(n_{unique}) \]

Where:
- \( W_{method} \) is the weight of the fingerprinting method.
- \( n_{unique} \) is the number of unique values the method can generate.

### 4.2 Normalization of Weights

Weights are normalized so that the sum of all weights equals 1. This ensures proportional distribution of importance among different methods.

\[ W_{normalized} = \frac{W_{method}}{\sum{W_{method}}} \]

## 5. Fingerprint Matching

### 5.1 Comparison Algorithm

The comparison algorithm calculates the matching score between a client fingerprint and each fingerprint in the database. The matching score is determined by summing the weights of the methods that have matching values.

### 5.2 Matching Threshold

A fingerprint is considered a match if the total matching score exceeds a predefined threshold (e.g., 90%).

\[ \text{Match Score} = \left( \frac{\sum{W_{matched}}}{\sum{W_{total}}} \right) \times 100 \]

Where:
- \( W_{matched} \) is the sum of weights for matching methods.
- \( W_{total} \) is the sum of all method weights.

## 6. System Architecture

### 6.1 API Endpoints

The system provides an HTTP API for fingerprint submission and comparison.

#### `/fingerprint` (POST)

- **Request Body**: JSON object containing the client's fingerprint data.
- **Response**: JSON object indicating whether a match was found and if the fingerprint was added to the database.

### 6.2 Database

The fingerprint data is stored in a database optimized for high read and write throughput. MongoDB is recommended for its flexibility and scalability.

## 7. Implementation

### 7.1 Node.js Server

The server is built using Node.js and Express. It handles HTTP requests, compares fingerprints, and interacts with the MongoDB database.

### 7.2 Code Example

An example implementation would include setting up a Node.js server with Express, connecting to MongoDB, and defining endpoints for fingerprint submission and comparison. The server would calculate weights, normalize them, and compare fingerprints against a stored database, adding new fingerprints if no match is found.

```javascript
const express = require('express');
const bodyParser = require('body-parser');
const mongoose = require('mongoose');
const app = express();
const port = 3000;

// Connect to MongoDB
mongoose.connect('mongodb://localhost:27017/fingerprintDB', { useNewUrlParser: true, useUnifiedTopology: true });

const fingerprintSchema = new mongoose.Schema({
    navigatorPlatform: String,
    webgl: String,
    // Add other fingerprint methods here
});

const Fingerprint = mongoose.model('Fingerprint', fingerprintSchema);

// Example unique value counts for different methods
const uniqueValueCounts = {
    navigatorPlatform: 10,
    webgl: 100000,
    // Add other methods and their unique value counts here
};

// Step 1: Determine the raw weights based on the log of unique value counts
const rawWeights = {};
for (const method in uniqueValueCounts) {
    rawWeights[method] = Math.log(uniqueValueCounts[method]);
}

// Step 2: Normalize the weights
const totalRawWeight = Object.values(rawWeights).reduce((sum, weight) => sum + weight, 0);
const normalizedWeights = {};
for (const method in rawWeights) {
    normalizedWeights[method] = rawWeights[method] / totalRawWeight;
}

// Function to compare fingerprints
function compareFingerprints(clientFingerprint, databaseFingerprint) {
    let totalWeight = 0;
    let matchWeight = 0;

    for (const method in clientFingerprint) {
        totalWeight += normalizedWeights[method];

        if (clientFingerprint[method] === databaseFingerprint[method]) {
            matchWeight += normalizedWeights[method];
        }
    }

    // Calculate the matching score as a percentage
    const matchScore = (matchWeight / totalWeight) * 100;

    // Determine if the fingerprints are considered a match
    return matchScore >= 90; // 90% threshold
}

app.use(bodyParser.json());

// API endpoint to check and add fingerprint
app.post('/fingerprint', async (req, res) => {
    const clientFingerprint = req.body;

    try {
        const fingerprints = await Fingerprint.find();

        for (const fingerprint of fingerprints) {
            if (compareFingerprints(clientFingerprint, fingerprint)) {
                return res.status(200).json({ match: true });
            }
        }

        // If no match found, add the fingerprint to the database
        const newFingerprint = new Fingerprint(clientFingerprint);
        await newFingerprint.save();
        res.status(201).json({ match: false, message: 'Fingerprint added to the database' });
    } catch (error) {
        res.status(500).json({ error: error.message });
    }
});

app.listen(port, () => {
    console.log(`Server running at http://localhost:${port}/`);
});
```

# Copyright
(c) 2024 Joe Rutkowski (Joe12387) Joe@dreggle.com - Released under the OverpoweredJS OS Public License
